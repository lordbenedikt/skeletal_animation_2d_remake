\chapter{Weiterführenede Techniken}
\label{cha:weitere_techniken}
%
%
\section{Variieren der Interpolierungsfunktion}
\label{sec:var_der_interpolierungsfunktion}
%
Die oben aufgezeigte Interpolierungsfunktion ist in den meisten Anwendungsfällen nicht geeignet. Betrachten wir eine Figur, welche ihren Arm hebt. Zwei Keyframes wurden definiert: Die Figur mit gesenktem Arm und mit gehobenem Arm. Spielen wir dieser Animation als Schleife ab, hebt und senkt die Figur ihren Arm wiederholt. Jedoch kommt es dabei zu abrupten Richtungswechseln, welche unnatürlich wirken. Das liegt daran, dass sich physikalische Objekte nach dem Gesetz der Trägheit bewegen. Um eine Veränderung der Bewegungsrichtung zu erreichen, muss das Objekt beschleunigt werden.\newline\newline
Um diese Eigenschaft physikalischer Objekte zu simulieren, bedarf es einer Interpolierungsfunktion, wessen Ableitung keine Sprünge macht, weder zwischen zwei Keyframes noch über angrenzende Keyframes hinweg. \newline\newline
%
Die wie folgt beschriebene Funktion $ease\_in\_out$ hat diese Eigenschaften. Sie lässt die Animation langsam beginnen, dann schneller werden und zum Ende wieder langsamer werden. (vgl. \cite{Febucci2018}). Die Funktion $lerp$ wird unverändert aus Formel 2.1 übernommen:
%
\begin{equation}
	ease\_in(x) = x^2
\end{equation}
\begin{equation}
	ease\_out(x) = (1-x)^2
\end{equation}
\begin{equation}
	ease\_in\_out(x) = lerp(ease\_in(x), ease\_out(x), x)
\end{equation}
\newline
Das Ergebnis von $ease\_in\_out(x)$ setzen wir statt x in $lerp$ ein
%
\begin{equation}
	lerp(a,b,ease\_in\_out(x))
\end{equation}
%
Und bekommen somit für jeden Zeitpunkt $t$ den richtigen Transformations-Wert.

\section{Inverse Kinematics}
%
Der Begriff „Inverse Kinematics“ (engl.: inverse Kinematik) kommt aus der Robotik. Um den Endeffektor eines Roboterarms mit n Gelenken und Verbindungsstücken an gewünschte kartesische Koordinaten mit gewünschter Orientierung zu bewegen, wird ein Algorithmus benötigt. Ziel dieses Algorithmus ist die Errechnung der passenden Einstellung jedes beteiligten Gelenks.\newline\newline

Eine Kette von Gelenken und Knochen in der Skelettanimation hat die gleiche Struktur wie ein Roboterarm mit Gelenken und Verbindungsstücken. Die gleichen Techniken, welche zur Lösung von Inverse Kinematics in der Robotik eingesetzt werden, sind daher auch in der Skelettanimation anwendbar.
%
\subsection{Algebraische Methode für 2 Gelenke}
\begin{figure}[!htb]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/roboterarm_0.png}
	\caption{Ausgangsposition}\label{fig:roboterarm_0}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/roboterarm_1.png}
	\caption{Zielposition}\label{fig:roboterarm_1}
	\endminipage\hfill
\end{figure}
Wir betrachten einen Roboterarm (siehe Abbildung \ref{fig:roboterarm_0}). Der Arm hat 2 Gelenke $A$ und $B$. $A$ ist fixiert. Am Ende des Arms ist der Endeffektor $C$ befestigt. Nun soll $C$ zur Zielposition $C'$ bewegt werden. Dieses Problem kann mit dem Gesetz des Kosinus gelöst werden. Abbildung \ref{fig:roboterarm_1} zeigt den Roboterarm in der Zielstellung. $a$, $b$ und $c$ bilden zusammen ein Dreieck. Mit dem Gesetz des Kosinus(Gleichung 3.1) ermitteln wir die Winkel $\gamma$ und $\alpha$.\\
\begin{equation}
	\begin{split}
		c^2=a^2+b^2-2ab \cdot cos(\theta)\\
		\theta=cos^{-1}\left(\frac{a^2+b^2-c^2}{2ab}\right)
	\end{split}
\end{equation}
\begin{equation*}
	\gamma=cos^{-1}\left(\frac{a^2+b^2-c^2}{2ab}\right)
\end{equation*}
\begin{equation*}
	\alpha=cos^{-1}\left(\frac{c^2+b^2-a^2}{2cb}\right)
\end{equation*}
Die Winkel, welche wir eigentlich brauchen sind $\gamma'$ und $\beta'$. Diese sind die benötigten Winkeleinstellungen für die jeweiligen Gelenke\footnote{Wir definieren senkrecht nach oben als den Nullwinkel und bewegen uns von hieraus im1 Uhrzeigersinn}. Wir berechnen die beiden gesuchten Winkel wie folgt:
\begin{align*}
		&\alpha' = \pi - \alpha \\
		&\gamma' = tan^{-1}\left(\frac{\vec{AC}_x}{\vec{AC}_y}\right)
\end{align*}
%
\subsection{Cyclic Coordinate Descent}
Cyclic Coordinate Descent (CCD) ist eine iterative Methode zur Lösung von Inverse Kinematics. Alle Gelenke welche Teil der betroffenen kinematischen Kette sind, werden nacheinander rotiert, um den Abstand zur Zielposition zu minimieren. Dabei werden alle Gelenke von der tiefsten bis zur höchsten Ebene in der Hierarchie abgearbeitet. Dieser Vorgang wird wiederholt bis der Endeffektor annäherungsweise die gewünschte Position erreicht hat.
\newline\newline
\begin{figure}[!htb]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/ccd_0.png}
	\caption{Ausgangsposition}\label{fig:ccd_0}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/ccd_1.png}
	\caption{}\label{fig:ccd_1}
	\endminipage\hfill
\end{figure} 
Abbildung \ref{fig:ccd_0} zeigt einen Roboterarm, welcher aus drei Knochen und drei Gelenken besteht. $A$ ist fixiert, $D$ ist der Endeffektor und soll zu $D_Ziel$ bewegt werden. Wir beginnen mit dem Knochen auf der untersten Ebene in der Hierarchie und rotieren diesen um den Punkt $C$, sodass $D$ auf $\vec{CD}_{Ziel}$, also dem Vektor vom betroffenen Gelenk zum Zielpunkt, liegt (siehe Abbildung \ref{fig:ccd_1}). Eine Ebene weiter oben rotieren wir um den Punkt $B$ (siehe Abbildung \ref{fig:ccd_2}), dann um den Punkt $A$ (siehe Abbildung \ref{fig:ccd_3}). Wiederholen wir diese Schritte, nähert sich D mit jeder Iteration $D_{Ziel}$ an. Der Algorithmus endet, sobald der Abstand von $D$ zu $D_{Ziel}$ einen vorher festgelegten Minimalabstand unterschreitet.
\begin{figure}[!htb]
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/ccd_2.png}
	\caption{}\label{fig:ccd_2}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/ccd_3.png}
	\caption{Zielposition}\label{fig:ccd_3}
	\endminipage\hfill
\end{figure}
Je nach Aufstellung kann es sein, dass viele Iterationen benötigt werden bis der Algorithmus auf diese Weise endet. Jedoch sind die Berechnungen und Transformationen nicht rechenintensiv, wodurch sich CCD für interaktive Echtzeitanwendungen eignet. (vgl. \cite{Fedor2003}: 207-208)
%
\section{Animation Layering}
%
Besonders in interaktiven Anwendungen ist kann es hilfreich sein, mehrere Animationen zu kombinieren. Erstellt man eine Animation für einen bestimmten Bereich, dann kann man diesen Bereich unabhängig vom Rest des Körpers animieren. Die Transformations-Werte aller betroffenen Gelenke werden je Keyframe abgespeichert. Diese werden interpoliert, um für jeden Frame wie weiter oben geschildert mit Forward Kinematics die globalen Transformations-Werte zu berechnen. Beim Animation Layering ersezt eine Ebene für den betroffen Bereich alle berechneten Werte darunterliegender Ebenen.
\newline\newline
Betrachten wir folgendes Beispiel: \newline
Zu animierende Figur hat 2 Animationen: Gehen und Winken. Die Gehen-Animation betrifft alle Gelenke der Figur. Die Winken-Animation hingegen betrifft nur die Gelenke des rechten Arms. Um beide Animationen zu kombinieren, werden die Rotationen der Armgelenke der Gehen-Animation durch die Rotationen der Winken-Animationen ersetzt.
%
\section{Additive Animation Blending}
%
Neben dem Animation Layering gibt es auch die Technik des ``Additive Animation Blending''. Zwei oder mehr Animationen werden zu einer neuen Animation zusammengefügt. Die neue Animation besteht zu vom Animator festgelegten Gewichtungen aus bereits vorhandenen Animationen. So ließe sich z.B. eine Gehen-Animation und eine Rennen-Animation kombinieren. 
%
\section{Meshes}
%
Ein Mesh(engl.: Netz) ist eine Ansammlung von Punkten und Dreiecken, welche sich aus den Verbindungslinien jeweils 3 dieser Punkte bilden. Ein solches Mesh kann als ein Array von Vertices(Punkte im Koordinatensystem) und ein Array von Indices definiert werden. Drei dieser Indices, welche auf je einen Punkt des ersten Arrays verweisen, bilden jeweils ein Dreieck. Mithilfe eines solchen Meshs können wir nun eine Textur aufspannen. Dazu definieren wir zusätlich ein Array von UVs(Bildkoordinaten). Je Punkt wird ein UV festgelegt. Unabhängig von den Koordinaten eines Punkts können wir ihm jetzt eine Position in der Textur-Bilddatei zuweisen. Mit den gegebenen Informationen kann nun die Farbe jedes Pixels innerhalb eines Dreiecks bestimmt werden. Dazu wenden wir den <<Triangle rendering algorithm>> an.
\newline\newline
Die Verwendung von Meshes zum Rendern von Grafiken bringt einige Vorteile mit sich, darunter: 
\newline
1) Bilder können nicht nur in ihrer ursprünlichen Erscheinung sondern auch in verzerrter Form angezeigt werden.
\newline
2) Transparente Bereiche von Bilddateien mit Alpha-Kanal können beim anzeichnen ignoriert werden, was die Effizienz erhöht.
%
\subsection{Mesh Generierung}
%
Je nach Verwendungszweck unterscheidet sich die Natur des am besten geeigneten Meshs. Es gilt die Größe der vom Mesh bedeckten Fläche zu minimieren, um die Effizienz zu maximieren. Das bedeutet, das Mesh sollte alle sichtbaren Bereiche bedecken, damit diese vollständig angezeigt werden, aber vollständig transparente Bereiche sollten möglichst ausgelassen werden.\newline
\newline
Die Dichte von Dreiecken in einem Bereich des Bildes und die Form und Lage der Dreiecke beeinflusst die Art und Weise, auf welche sich die angezeigte Grafik bei Verzerrung des Meshs verändert. Übermäßig große Dreiecke, besonders in Bereichen, welche stark verzerrt werden, führen meist zu einem unnatürlich erscheinendem Ergebnis.
%
\subsubsection{Marching Squares Algorithmus}
Um ein enganliegendes Mesh zu generieren, berechnen wir erst einmal eine Kontur für unsere Bilddatei, in unserem Fall ein Bild im PNG-Format. Um aus einer Bilddatei eine Kontur zu generieren, kann der Marching Squares Algorithmus (engl.: wandernde Quadrate) angewandt werden. Die Kontur sollte etwas weiter als die tatsächliche Kontur des abgebildeten Objekts sein. Das dient dazu, dass alle sichtbaren Teile beim Rendern später vollständig gezeichnet werden. Zudem ermöglicht es das aussortieren überflüssiger Eckpunkte, die durch den Marching Squares Algorithmus entstehen. (vgl. \cite{Maple2003})\newline\newline

Unser Ziel ist es, eine Kontur um alle sichtbaren Teile der Bilddatei zu ziehen. Als sichtbar sehen wir alles an, was einen festgelegten Alpha-Schwellwert überschreitet. Dazu generieren wir aus dem Alpha-Kanal des Bildes ein Distanzfeld. Das Distanzfeld ist eine Grauwertmatrix der selben Auflösung des Bildes. Für jeden Pixel der Bilddatei wird hier die Distanz zum nächstgelegenen sichtbaren Pixel berechnet und festgehalten. Anhand eines weiteren Schwellwerts generieren wir ein Raster, dessen Zellen jeweils entweder $true$ für sichtbar oder $false$ für unsichtbar sind.
Auf dieses Raster wird nun ein Konturraster gelegt, welches in x- und y-Richtung jeweils eine Zelle kleiner ist. Die Eckpunkte des Konturrasters liegen jeweils im Zentrum einer der Binärzellen. Jeder Zelle des Konturrasters wird ein Wert zugewiesen. Dieser ergibt sich daraus, ob die Werte der vier Ecken dieser Zelle $true$ oder $false$ sind. Den Ecken werden die Werte $2^0$, $2^1$, $2^3$ und $2^4$ zugewiesen. (siehe Abb.: \ref{fig:marching_square_corners})
\cite{Wisq2022}
\begin{figure}[!htb]
	\minipage{0.3\textwidth}
	\includegraphics[width=\linewidth]{img/marching_square_corners.png}
	\caption{Konturzelle}\label{fig:marching_square_corners}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\includegraphics[width=\linewidth]{img/marching_square_wiki.png}
	\caption{Mögliche Fälle (vgl. \cite{Wisq2022	}})}\label{fig:marching_square_cases}
	\endminipage\hfill
\end{figure}
%
Für jede der 15 möglichen Kombinationen wird jeweils ein entsprechendes Konturstück festgelegt. Diese 15 Fälle können in einer Lookup-Tabelle gespeichert werden. Fügt man all diese Stücke zusammen ergibt sich die gesuchte Kontur. Abb. \ref{fig:marching_square_example} und \ref{fig:marching_square_example_solved} zeigen die Vorgangsweise an einem Beispiel.
\begin{figure}[!htb]
	\minipage{0.4\textwidth}
	\includegraphics[width=\linewidth]{img/marching_square_example.png}
	\caption{Ausgangsposition}\label{fig:marching_square_example}
	\endminipage\hfill
	\minipage{0.4\textwidth}
	\includegraphics[width=\linewidth]{img/marching_square_example_solved.png}
	\caption{Zielposition}\label{fig:marching_square_example_solved}
	\endminipage\hfill
\end{figure}
%
\subsection{Mesh Deformierung}
Die Deformierung des Meshs erfolgt durch die Verschiebung der dazugehörigen Punkte. Um eine solche Deformierung durch das Transformieren der Skelett-Knochen zu erreichen, legen wir den Einflussgrad jedes Knochens auf jeden Mesh-Punkt fest. Zusätzlich legen wir die Lage jedes Punktes relativ zur Lage, Rotation und Skalierung jedes auf ihn Einfluss nehmenden Knochens fest. Für jeden Mesh-Punkt ergeben sich nun bei beliebiger Skelettpose eine Anzahl an globalen Koordinaten. Die endgültige Punktkoordinate ergibt sich zu festgelegten Anteielen aus diesen global Koordinaten. Das angepasste Mesh geben wir an die Graphics Library weiter, welche sich um das Rendern kümmert.